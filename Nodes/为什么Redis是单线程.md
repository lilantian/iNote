# 为什么Redis是单线程？
[为什么Redis是单线程](https://www.cnblogs.com/blogtech/p/11742057.html)

1. 以前一直有个误区，以为：高性能服务器一定是多线程来实现的  
原因很简单因为误区二导致的：多线程一定比单线程效率高，其实不然！  
在说这个事前希望大家都能对CPU、内存、硬盘的速度都有了解了，这样可能理解得更深刻一点，不了解的点：CPU到底比内存跟硬盘快多少

2. redis核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率高，为什么呢，因为多线程的本质就是CPU模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是剩下问的且换，对于一个内存的刺痛来说，它没有上下文的且换就是效率高的。redis有单个CPU绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案——阿里 沈询  
因为一次CPU上下文的且换大概在1500ns左右。  
从内存中读取1MB的连续数据，耗时大约为250us，假设1MB的数据由多个线程读取1000次，那么就有1000次时间上下文的且换，  
那么就有1500ns * 1000 = 1500us，我单线程读完1MB的数据有才250us，你光时间上下文的且换就用了1500us了，我还不算你每次读取一点数据的时间

3. 那什么时候用多线程的方案呢？  
【IOPS(Input/Output Opertions Per Second) 是一个用于计算机存储设备（如硬盘（HDD）、固态硬盘（SSD）或存储区域网络（SAN）性能测试的量测方式】  
【吞吐量是指对网络、设备、端口、虚电路或其他设置，单位时间内成功地传送数据的数量（以比特、字节、分组等测量）】  
答案是：下层的村塾等慢速的情况。比如磁盘  
内存是一个IOPS非常高的系统，因为我想申请一块就申请一块内存，销毁一块内存我就销毁一块内存，内存的申请和销毁是很容易的。而且内存是可以动态的申请大小的。  
磁盘的特性是：IPOS很低很低，但吞吐量很高。这就因为着，大量的读写操作都必须攒到一起，再提交到磁盘的时候，性能最高。未什么呢？  
如果我有一个事务组的操作（就是几个已经分开了的事情请求，比如写读写读写，那么五个造作在一起），在内存中，因为IOPS非常高，我可以一个一个的完成，但是如果在磁盘中也有这种请求方式的话，  
我第一个写操作是这样完成的，我先在磁盘中寻址，大概花费10ms，然后我读一个数据可能花费1ms然后我再运算（忽略不计），再写回硬盘又是10ms，总共21ms  
第二个操作去读花了10ms，第三个又是写花费了21ms，然后我再读10ms，写21ms，五个请求总共花费83ms，这还是最理想的情况下，这如果再内存中，大概1ms不到。  
所以队医磁盘来说，它吞吐量这么大，那么最好的方案肯定是我将N个请求一起放在buff里，然后一起去提交。  
方法就是用异步：将请求和处理的线程不绑定，请求的线程将请求放在一个buff里，然后等buff快满了，处理的线程再去处理这个buff。然后由这大哥buff统一的去写入磁盘，或者读磁盘，这样效率就是最高的。java里的IO不就是这么干的么~  
对于慢速设备，这猴子那个处理方式就是最佳的，慢速设备有磁盘，网络，SSD等等，  
多线程，异步的方式处理这些问题费城常见，大名鼎鼎的netty就是这么干的。  

4. 为何单核cpu绑定一块内存效率最高  
“我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以我们可以手动地为其分配CPU核，而不会过多地占用CPU”，默认情况下单线程在进行系统调用的时候会随机使用CPU内核，为了优化Redis，我们客户以使用工具为单线程绑定固定的CPU内核，减少不必要的性能损耗！  
redis作为单线程模型的程序，为了充分利用多核CPU，常常在一台server上回启动多个实例，而为了减少且换的开销，有必要为每个实例指定其所运行的CPU。  
Linux上taskset可以将某个进程绑定到一个特定的CPU。你比操作系统更了解自己的程序，为了避免调度器愚蠢的调度你的程序，或是为了在多线程程序中避免缓存失效造成的开销。  

顺便再提一句：redis的瓶颈在网络上。，。。









